# PackageTraker å¾Œç«¯æ¨æ’­ç³»çµ±å¯¦æ–½è¨ˆåŠƒ

## èƒŒæ™¯èˆ‡ç›®æ¨™

### å•é¡Œé™³è¿°
ç›®å‰ PackageTraker åƒ…åœ¨ App é–‹å•Ÿæ™‚æ‰æœƒæ›´æ–°åŒ…è£¹ç‹€æ…‹ï¼Œç¼ºä¹å³æ™‚æ€§ã€‚ç”¨æˆ¶ç„¡æ³•åœ¨åŒ…è£¹åˆ°è²¨æ™‚ç«‹å³æ”¶åˆ°é€šçŸ¥ï¼Œéœ€è¦æ‰‹å‹•é€²å…¥ App åˆ·æ–°ã€‚

### è§£æ±ºæ–¹æ¡ˆ
å¯¦ä½œ **Server-side æ¨æ’­ç³»çµ±**ï¼šå¾Œç«¯æ¯ 15 åˆ†é˜è‡ªå‹•æª¢æŸ¥æ‰€æœ‰åŒ…è£¹ç‹€æ…‹ï¼Œç•¶åµæ¸¬åˆ°ç‹€æ…‹è®ŠåŒ–ï¼ˆç‰¹åˆ¥æ˜¯åˆ°è²¨æ™‚ï¼‰ç«‹å³ç™¼é€æ¨æ’­é€šçŸ¥åˆ°ç”¨æˆ¶è¨­å‚™ï¼Œå³ä½¿ App å·²é—œé–‰ä¹Ÿèƒ½æ”¶åˆ°ã€‚

### æŠ€è¡“é¸å‹
- **å¾Œç«¯**ï¼šFirebase (Firestore + Cloud Functions + Cloud Scheduler)
- **æ¨æ’­**ï¼šFCM (Firebase Cloud Messaging) + APNs
- **èº«ä»½è­˜åˆ¥**ï¼šApple Sign Inï¼ˆè·¨è¨­å‚™åŒæ­¥ï¼‰
- **API**ï¼šTrack.TW APIï¼ˆå…±ç”¨å–®ä¸€ Tokenï¼‰

---

## æ¶æ§‹è¨­è¨ˆ

### æ•´é«”æ¶æ§‹åœ–

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  iOS App (PackageTraker)                 â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ æœ¬åœ°è³‡æ–™å±¤ (SwiftData)                              â”‚ â”‚
â”‚  â”‚  - Package (æœ¬åœ°å¿«å–)                               â”‚ â”‚
â”‚  â”‚  - TrackingEvent                                    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                         â†•                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Firebase æ•´åˆå±¤                                     â”‚ â”‚
â”‚  â”‚  - FirebaseAuthService (Apple Sign In)             â”‚ â”‚
â”‚  â”‚  - FirebaseSyncService (é›™å‘åŒæ­¥)                  â”‚ â”‚
â”‚  â”‚  - FirebasePushService (FCM Token ç®¡ç†)            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†• (HTTPS/WebSocket)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Firebase Backend (GCP)                     â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Firestore Database                                  â”‚ â”‚
â”‚  â”‚                                                      â”‚ â”‚
â”‚  â”‚  /users/{userId}                                     â”‚ â”‚
â”‚  â”‚    - appleId, email, fcmToken                        â”‚ â”‚
â”‚  â”‚    - notificationSettings                            â”‚ â”‚
â”‚  â”‚                                                      â”‚ â”‚
â”‚  â”‚  /users/{userId}/packages/{packageId}                â”‚ â”‚
â”‚  â”‚    - trackingNumber, carrier, status                 â”‚ â”‚
â”‚  â”‚    - trackTwRelationId, customName                   â”‚ â”‚
â”‚  â”‚    - lastUpdated, isArchived                         â”‚ â”‚
â”‚  â”‚                                                      â”‚ â”‚
â”‚  â”‚  /users/{userId}/packages/{packageId}/events/...     â”‚ â”‚
â”‚  â”‚    - timestamp, status, description, location        â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Cloud Functions (Node.js/TypeScript)                â”‚ â”‚
â”‚  â”‚                                                      â”‚ â”‚
â”‚  â”‚  â‘  packageTrackingScheduler (æ¯ 15 åˆ†é˜)            â”‚ â”‚
â”‚  â”‚     - æŸ¥è©¢æ‰€æœ‰æœªå®ŒæˆåŒ…è£¹                             â”‚ â”‚
â”‚  â”‚     - å‘¼å« Track.TW API                              â”‚ â”‚
â”‚  â”‚     - æ¯”å°ç‹€æ…‹è®ŠåŒ–                                   â”‚ â”‚
â”‚  â”‚     - æ›´æ–° Firestore                                 â”‚ â”‚
â”‚  â”‚                                                      â”‚ â”‚
â”‚  â”‚  â‘¡ onPackageStatusChange (Firestore Trigger)        â”‚ â”‚
â”‚  â”‚     - åµæ¸¬ status æ¬„ä½è®ŠåŒ–                           â”‚ â”‚
â”‚  â”‚     - ç™¼é€ FCM æ¨æ’­                                  â”‚ â”‚
â”‚  â”‚                                                      â”‚ â”‚
â”‚  â”‚  â‘¢ syncPackageFromClient (HTTPS Callable)           â”‚ â”‚
â”‚  â”‚     - è™•ç†å®¢æˆ¶ç«¯åŒ…è£¹åŒæ­¥è«‹æ±‚                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Cloud Scheduler                                      â”‚ â”‚
â”‚  â”‚  - Cron: "*/15 * * * *" (æ¯ 15 åˆ†é˜)                 â”‚ â”‚
â”‚  â”‚  - Pub/Sub Topic: package-tracking-cron             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“
              Track.TW API (å…±ç”¨ Token)
```

---

## è³‡æ–™çµæ§‹è¨­è¨ˆ

### Firestore Collections

```typescript
// Collection: users
/users/{userId}  // userId = Apple User Identifier
{
  appleId: string                     // Apple Sign In User ID
  email: string?                      // ä½¿ç”¨è€… email (optional)
  fcmToken: string                    // FCM æ¨æ’­ Token
  createdAt: Timestamp
  lastActive: Timestamp
  notificationSettings: {
    enabled: boolean                  // ç¸½é–‹é—œ
    arrivalNotification: boolean      // åˆ°è²¨é€šçŸ¥
    pickupReminder: boolean           // å–è²¨æé†’
  }
}

// Subcollection: packages (æ¯ç”¨æˆ¶ç¨ç«‹)
/users/{userId}/packages/{packageId}  // packageId = UUID
{
  trackingNumber: string
  carrier: string                     // Carrier.rawValue (e.g., "sevenEleven")
  status: string                      // TrackingStatus.rawValue (e.g., "arrivedAtStore")

  // Track.TW æ•´åˆ
  trackTwRelationId: string           // Track.TW relation UUID

  // åŸºæœ¬è³‡è¨Š
  customName: string?
  pickupLocation: string?
  storeName: string?
  pickupCode: string?

  // æ™‚é–“æˆ³è¨˜
  lastUpdated: Timestamp
  createdAt: Timestamp

  // ç‹€æ…‹ç®¡ç†
  isArchived: boolean
  lastNotifiedStatus: string?         // ä¸Šæ¬¡ç™¼é€æ¨æ’­çš„ç‹€æ…‹ (é¿å…é‡è¤‡)

  // è¨‚å–®è³‡è¨Š
  amount: number?
  paymentMethod: string?
  purchasePlatform: string?
  notes: string?
}

// Subcollection: events (è¿½è¹¤äº‹ä»¶)
/users/{userId}/packages/{packageId}/events/{eventId}
{
  timestamp: Timestamp
  status: string                      // TrackingStatus.rawValue
  description: string                 // äº‹ä»¶æè¿° (ä¸­æ–‡)
  location: string?                   // åœ°é»
}
```

### Security Rules

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper: æª¢æŸ¥ç”¨æˆ¶æ˜¯å¦å·²ç™»å…¥
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper: æª¢æŸ¥æ˜¯å¦ç‚ºè³‡æ–™æ“æœ‰è€…
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // ç”¨æˆ¶è³‡æ–™ï¼šåªèƒ½å­˜å–è‡ªå·±çš„
    match /users/{userId} {
      allow read, write: if isAuthenticated() && isOwner(userId);

      // åŒ…è£¹è³‡æ–™ï¼šåªèƒ½å­˜å–è‡ªå·±çš„
      match /packages/{packageId} {
        allow read, write: if isAuthenticated() && isOwner(userId);

        // è¿½è¹¤äº‹ä»¶ï¼šå¯è®€å–ï¼Œä½†åªå…è¨± Cloud Functions å¯«å…¥
        match /events/{eventId} {
          allow read: if isAuthenticated() && isOwner(userId);
          allow write: if false;  // åªå…è¨±å¾Œç«¯å¯«å…¥
        }
      }
    }
  }
}
```

---

## åˆ†éšæ®µå¯¦æ–½è¨ˆåŠƒ

### Phase 1: Firebase åŸºç¤è¨­å®šèˆ‡ Apple Sign In (2-3 å¤©)

#### ç›®æ¨™
å»ºç«‹ Firebase å°ˆæ¡ˆã€æ•´åˆ Apple Sign Inã€å¯¦ç¾åŸºæœ¬çš„ç”¨æˆ¶èº«ä»½è­˜åˆ¥ã€‚

#### é—œéµæª”æ¡ˆ

**æ–°å¢æª”æ¡ˆï¼š**
- `PackageTraker/GoogleService-Info.plist` - Firebase é…ç½®æª”
- `PackageTraker/Services/Firebase/FirebaseAuthService.swift` - Apple Sign In ç®¡ç†
- `PackageTraker/Views/Auth/SignInView.swift` - ç™»å…¥ç•«é¢
- `PackageTraker/PackageTraker.entitlements` - Apple Sign In entitlement

**ä¿®æ”¹æª”æ¡ˆï¼š**
- `PackageTraker/PackageTrakerApp.swift` - åˆå§‹åŒ– Firebase
- `PackageTraker/Info.plist` - æ–°å¢æ¬Šé™èªªæ˜
- `Package.swift` (SPM) - æ–°å¢ Firebase SDK ä¾è³´

#### å¯¦ä½œæ­¥é©Ÿ

1. **Firebase Console è¨­å®š**
   ```bash
   # 1. å‰å¾€ Firebase Console: https://console.firebase.google.com/
   # 2. å»ºç«‹æ–°å°ˆæ¡ˆ "PackageTraker" æˆ–ä½¿ç”¨ç¾æœ‰å°ˆæ¡ˆ
   # 3. æ–°å¢ iOS App
   #    - Bundle ID: com.yourname.PackageTraker
   # 4. ä¸‹è¼‰ GoogleService-Info.plist
   # 5. å•Ÿç”¨ä»¥ä¸‹æœå‹™ï¼š
   #    - Authentication (Apple Sign In)
   #    - Firestore Database
   #    - Cloud Functions
   #    - Cloud Messaging
   ```

2. **Apple Developer Console è¨­å®š**
   ```bash
   # 1. å‰å¾€ https://developer.apple.com/account/
   # 2. Identifiers > App IDs > ä½ çš„ App
   # 3. å•Ÿç”¨ "Sign in with Apple" capability
   # 4. è¨­å®š Service ID (ç”¨æ–¼ Firebase)
   # 5. ä¸‹è¼‰æ›´æ–°çš„ Provisioning Profile
   ```

3. **å®‰è£ Firebase SDK (SPM)**
   ```swift
   // Package.swift dependencies:
   .package(url: "https://github.com/firebase/firebase-ios-sdk", from: "10.0.0")

   // Targets dependencies:
   .product(name: "FirebaseAuth", package: "firebase-ios-sdk"),
   .product(name: "FirebaseFirestore", package: "firebase-ios-sdk"),
   .product(name: "FirebaseMessaging", package: "firebase-ios-sdk")
   ```

4. **å»ºç«‹ FirebaseAuthService.swift**
   ```swift
   import FirebaseAuth
   import FirebaseCore
   import AuthenticationServices
   import CryptoKit

   @MainActor
   final class FirebaseAuthService: NSObject, ObservableObject {
       static let shared = FirebaseAuthService()

       @Published var currentUser: User?
       @Published var isAuthenticated = false
       @Published var isLoading = false

       private var currentNonce: String?

       private override init() {
           super.init()

           // ç›£è½èªè­‰ç‹€æ…‹
           Auth.auth().addStateDidChangeListener { [weak self] _, user in
               Task { @MainActor in
                   self?.currentUser = user
                   self?.isAuthenticated = user != nil
               }
           }
       }

       // MARK: - Apple Sign In

       func signInWithApple(credential: ASAuthorizationAppleIDCredential) async throws {
           guard let nonce = currentNonce,
                 let appleIDToken = credential.identityToken,
                 let idTokenString = String(data: appleIDToken, encoding: .utf8) else {
               throw AuthError.invalidCredential
           }

           let firebaseCredential = OAuthProvider.credential(
               withProviderID: "apple.com",
               idToken: idTokenString,
               rawNonce: nonce
           )

           isLoading = true
           defer { isLoading = false }

           let result = try await Auth.auth().signIn(with: firebaseCredential)
           currentUser = result.user

           // åˆæ¬¡ç™»å…¥æ™‚å»ºç«‹ç”¨æˆ¶è³‡æ–™
           await createUserProfileIfNeeded(user: result.user, credential: credential)
       }

       func startSignInWithAppleFlow() -> ASAuthorizationAppleIDRequest {
           let nonce = randomNonceString()
           currentNonce = nonce

           let request = ASAuthorizationAppleIDProvider().createRequest()
           request.requestedScopes = [.email, .fullName]
           request.nonce = sha256(nonce)

           return request
       }

       func signOut() throws {
           try Auth.auth().signOut()
           currentUser = nil
       }

       // MARK: - Helpers

       private func createUserProfileIfNeeded(user: User, credential: ASAuthorizationAppleIDCredential) async {
           let db = Firestore.firestore()
           let userRef = db.collection("users").document(user.uid)

           let userDoc = try? await userRef.getDocument()
           if userDoc?.exists == true { return }

           // å»ºç«‹ç”¨æˆ¶è³‡æ–™
           let userData: [String: Any] = [
               "appleId": credential.user,
               "email": credential.email ?? "",
               "createdAt": FieldValue.serverTimestamp(),
               "lastActive": FieldValue.serverTimestamp(),
               "notificationSettings": [
                   "enabled": true,
                   "arrivalNotification": true,
                   "pickupReminder": true
               ]
           ]

           try? await userRef.setData(userData)
       }

       private func randomNonceString(length: Int = 32) -> String {
           precondition(length > 0)
           var randomBytes = [UInt8](repeating: 0, count: length)
           let errorCode = SecRandomCopyBytes(kSecRandomDefault, randomBytes.count, &randomBytes)
           if errorCode != errSecSuccess {
               fatalError("Unable to generate nonce. SecRandomCopyBytes failed with OSStatus \(errorCode)")
           }

           let charset: [Character] =
               Array("0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._")

           let nonce = randomBytes.map { byte in
               charset[Int(byte) % charset.count]
           }

           return String(nonce)
       }

       private func sha256(_ input: String) -> String {
           let inputData = Data(input.utf8)
           let hashedData = SHA256.hash(data: inputData)
           let hashString = hashedData.compactMap {
               String(format: "%02x", $0)
           }.joined()

           return hashString
       }
   }

   enum AuthError: LocalizedError {
       case invalidCredential

       var errorDescription: String? {
           switch self {
           case .invalidCredential:
               return String(localized: "auth.error.invalidCredential")
           }
       }
   }
   ```

5. **å»ºç«‹ SignInView.swift**
   ```swift
   import SwiftUI
   import AuthenticationServices

   struct SignInView: View {
       @EnvironmentObject private var authService: FirebaseAuthService
       @State private var showError = false
       @State private var errorMessage = ""

       var body: some View {
           VStack(spacing: 32) {
               // Logo
               Image("AppLogo")
                   .resizable()
                   .scaledToFit()
                   .frame(width: 120, height: 120)

               // æ¨™é¡Œ
               VStack(spacing: 12) {
                   Text(AppConfiguration.appName)
                       .font(.largeTitle)
                       .fontWeight(.bold)

                   Text("auth.signIn.subtitle")
                       .font(.body)
                       .foregroundStyle(.secondary)
                       .multilineTextAlignment(.center)
               }

               Spacer()

               // Apple Sign In æŒ‰éˆ•
               SignInWithAppleButton(
                   .signIn,
                   onRequest: { request in
                       request = authService.startSignInWithAppleFlow()
                   },
                   onCompletion: { result in
                       handleSignInResult(result)
                   }
               )
               .signInWithAppleButtonStyle(.white)
               .frame(height: 50)
               .cornerRadius(8)

               // éš±ç§èªªæ˜
               Text("auth.signIn.privacyNote")
                   .font(.caption)
                   .foregroundStyle(.secondary)
                   .multilineTextAlignment(.center)
           }
           .padding(24)
           .alert("auth.error.title", isPresented: $showError) {
               Button("common.ok", role: .cancel) {}
           } message: {
               Text(errorMessage)
           }
       }

       private func handleSignInResult(_ result: Result<ASAuthorization, Error>) {
           switch result {
           case .success(let authorization):
               guard let credential = authorization.credential as? ASAuthorizationAppleIDCredential else {
                   return
               }

               Task {
                   do {
                       try await authService.signInWithApple(credential: credential)
                   } catch {
                       errorMessage = error.localizedDescription
                       showError = true
                   }
               }

           case .failure(let error):
               if (error as NSError).code != ASAuthorizationError.canceled.rawValue {
                   errorMessage = error.localizedDescription
                   showError = true
               }
           }
       }
   }
   ```

6. **ä¿®æ”¹ PackageTrakerApp.swift**
   ```swift
   import SwiftUI
   import SwiftData
   import FirebaseCore

   @main
   struct PackageTrakerApp: App {
       @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
       @StateObject private var authService = FirebaseAuthService.shared
       @State private var refreshService = PackageRefreshService()
       @State private var showSplash = true

       init() {
           // åˆå§‹åŒ– Firebase
           FirebaseApp.configure()

           // è¨­ç½®é€šçŸ¥ä»£ç†
           UNUserNotificationCenter.current().delegate = NotificationDelegate.shared
       }

       var body: some Scene {
           WindowGroup {
               Group {
                   if authService.isAuthenticated {
                       // å·²ç™»å…¥ï¼šé¡¯ç¤ºä¸»ç•«é¢
                       ZStack {
                           MainTabView()
                               .environment(refreshService)

                           if showSplash {
                               SplashView(refreshService: refreshService) {
                                   showSplash = false
                               }
                           }
                       }
                   } else {
                       // æœªç™»å…¥ï¼šé¡¯ç¤ºç™»å…¥ç•«é¢
                       SignInView()
                   }
               }
               .preferredColorScheme(.dark)
               .environmentObject(authService)
           }
           .modelContainer(for: [Package.self, TrackingEvent.self, LinkedEmailAccount.self])
       }
   }

   // AppDelegate for FCM
   class AppDelegate: NSObject, UIApplicationDelegate {
       func application(
           _ application: UIApplication,
           didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
       ) -> Bool {
           return true
       }
   }
   ```

7. **æ–°å¢æœ¬åœ°åŒ–å­—ä¸²**
   ```strings
   // en.lproj/Localizable.strings
   "auth.signIn.subtitle" = "Sign in to sync your packages across devices and receive push notifications";
   "auth.signIn.privacyNote" = "We respect your privacy. Your data is securely stored and only used for package tracking.";
   "auth.error.title" = "Sign In Failed";
   "auth.error.invalidCredential" = "Invalid Apple Sign In credential";

   // zh-Hant.lproj/Localizable.strings
   "auth.signIn.subtitle" = "ç™»å…¥ä»¥è·¨è¨­å‚™åŒæ­¥åŒ…è£¹ä¸¦æ¥æ”¶æ¨æ’­é€šçŸ¥";
   "auth.signIn.privacyNote" = "æˆ‘å€‘å°Šé‡æ‚¨çš„éš±ç§ã€‚æ‚¨çš„è³‡æ–™å®‰å…¨å„²å­˜ï¼Œåƒ…ç”¨æ–¼åŒ…è£¹è¿½è¹¤ã€‚";
   "auth.error.title" = "ç™»å…¥å¤±æ•—";
   "auth.error.invalidCredential" = "ç„¡æ•ˆçš„ Apple ç™»å…¥æ†‘è­‰";

   // zh-Hans.lproj/Localizable.strings
   "auth.signIn.subtitle" = "ç™»å½•ä»¥è·¨è®¾å¤‡åŒæ­¥åŒ…è£¹å¹¶æ¥æ”¶æ¨æ’­é€šçŸ¥";
   "auth.signIn.privacyNote" = "æˆ‘ä»¬å°Šé‡æ‚¨çš„éšç§ã€‚æ‚¨çš„èµ„æ–™å®‰å…¨å‚¨å­˜ï¼Œä»…ç”¨äºåŒ…è£¹è¿½è¸ªã€‚";
   "auth.error.title" = "ç™»å½•å¤±è´¥";
   "auth.error.invalidCredential" = "æ— æ•ˆçš„ Apple ç™»å½•å‡­è¯";
   ```

#### é©—è­‰æ–¹æ³•
```bash
# 1. åŸ·è¡Œ App
# 2. é»æ“Š "Sign in with Apple" æŒ‰éˆ•
# 3. å®Œæˆ Apple ç™»å…¥æµç¨‹
# 4. æª¢æŸ¥ Firebase Console > Authentication > Users æ˜¯å¦æœ‰æ–°ç”¨æˆ¶
# 5. æª¢æŸ¥ Firestore > users/{userId} æ˜¯å¦å»ºç«‹æ–‡ä»¶
```

---

### Phase 2: Firestore è³‡æ–™åŒæ­¥èˆ‡ FCM æ¨æ’­ (3-4 å¤©)

#### ç›®æ¨™
å»ºç«‹ iOS ç«¯åˆ° Firestore çš„é›™å‘åŒæ­¥ï¼Œä¸¦å¯¦ç¾ FCM Token è¨»å†Šã€‚

#### é—œéµæª”æ¡ˆ

**æ–°å¢æª”æ¡ˆï¼š**
- `PackageTraker/Services/Firebase/FirebaseSyncService.swift` - Firestore åŒæ­¥é‚è¼¯
- `PackageTraker/Services/Firebase/FirebasePushService.swift` - FCM Token ç®¡ç†
- `PackageTraker/Services/Firebase/FirebaseModels.swift` - Firestore æ¨¡å‹å°æ˜ 

**ä¿®æ”¹æª”æ¡ˆï¼š**
- `PackageTraker/Services/PackageRefreshService.swift` - æ•´åˆ Firestore åŒæ­¥
- `PackageTraker/Views/AddPackage/AddPackageView.swift` - æ–°å¢åŒ…è£¹æ™‚åŒæ­¥
- `PackageTraker/PackageTrakerApp.swift` - è¨»å†Š FCM

#### å¯¦ä½œæ­¥é©Ÿ

1. **å»ºç«‹ FirebaseSyncService.swift**
   ```swift
   import FirebaseFirestore
   import SwiftData

   @MainActor
   final class FirebaseSyncService: ObservableObject {
       static let shared = FirebaseSyncService()

       private let db = Firestore.firestore()
       @Published var isSyncing = false
       @Published var lastSyncDate: Date?

       private var packageListeners: [String: ListenerRegistration] = [:]

       private init() {}

       // MARK: - ä¸Šå‚³åŒ…è£¹åˆ° Firestore

       func syncPackageToCloud(_ package: Package) async throws {
           guard let userId = FirebaseAuthService.shared.currentUser?.uid else {
               throw SyncError.notAuthenticated
           }

           let packageRef = db.collection("users").document(userId)
               .collection("packages").document(package.id.uuidString)

           let packageData = packageToFirestore(package)
           try await packageRef.setData(packageData, merge: true)

           // åŒæ­¥äº‹ä»¶
           for event in package.events {
               try await syncEventToCloud(event, packageId: package.id.uuidString, userId: userId)
           }
       }

       // MARK: - æ‰¹æ¬¡ä¸Šå‚³æœ¬åœ°åŒ…è£¹

       func syncAllLocalPackages(context: ModelContext) async throws {
           guard let userId = FirebaseAuthService.shared.currentUser?.uid else {
               throw SyncError.notAuthenticated
           }

           isSyncing = true
           defer { isSyncing = false }

           let descriptor = FetchDescriptor<Package>()
           let allPackages = try context.fetch(descriptor)

           print("[Sync] Uploading \(allPackages.count) local packages to Firestore...")

           for package in allPackages {
               try await syncPackageToCloud(package)
           }

           lastSyncDate = Date()
           print("[Sync] âœ… All packages synced successfully")
       }

       // MARK: - ç›£è½ Firestore è®ŠåŒ– (å³æ™‚åŒæ­¥)

       func observePackageChanges(context: ModelContext) {
           guard let userId = FirebaseAuthService.shared.currentUser?.uid else {
               return
           }

           let packagesRef = db.collection("users").document(userId).collection("packages")

           let listener = packagesRef.addSnapshotListener { [weak self] snapshot, error in
               guard let documents = snapshot?.documents else {
                   print("[Sync] Error listening to packages: \(error?.localizedDescription ?? "unknown")")
                   return
               }

               Task { @MainActor in
                   for document in documents {
                       self?.updateLocalPackage(from: document, in: context)
                   }
               }
           }

           packageListeners[userId] = listener
       }

       func stopObserving() {
           packageListeners.values.forEach { $0.remove() }
           packageListeners.removeAll()
       }

       // MARK: - Helpers

       private func packageToFirestore(_ package: Package) -> [String: Any] {
           return [
               "trackingNumber": package.trackingNumber,
               "carrier": package.carrierRawValue,
               "status": package.statusRawValue,
               "customName": package.customName ?? "",
               "trackTwRelationId": package.trackTwRelationId ?? "",
               "pickupLocation": package.pickupLocation ?? "",
               "storeName": package.storeName ?? "",
               "pickupCode": package.pickupCode ?? "",
               "lastUpdated": Timestamp(date: package.lastUpdated),
               "createdAt": Timestamp(date: package.createdAt),
               "isArchived": package.isArchived,
               "amount": package.amount ?? 0,
               "paymentMethod": package.paymentMethodRawValue ?? "",
               "purchasePlatform": package.purchasePlatform ?? "",
               "notes": package.notes ?? ""
           ]
       }

       private func syncEventToCloud(_ event: TrackingEvent, packageId: String, userId: String) async throws {
           let eventRef = db.collection("users").document(userId)
               .collection("packages").document(packageId)
               .collection("events").document(event.id.uuidString)

           let eventData: [String: Any] = [
               "timestamp": Timestamp(date: event.timestamp),
               "status": event.statusRawValue,
               "description": event.eventDescription,
               "location": event.location ?? ""
           ]

           try await eventRef.setData(eventData)
       }

       private func updateLocalPackage(from document: DocumentSnapshot, in context: ModelContext) {
           guard let data = document.data(),
                 let uuidString = document.documentID,
                 let uuid = UUID(uuidString: uuidString) else { return }

           // æŸ¥æ‰¾ç¾æœ‰åŒ…è£¹
           let descriptor = FetchDescriptor<Package>(
               predicate: #Predicate { $0.id == uuid }
           )
           guard let package = try? context.fetch(descriptor).first else { return }

           // æ›´æ–°ç‹€æ…‹ï¼ˆåƒ…ç•¶é›²ç«¯è¼ƒæ–°æ™‚ï¼‰
           if let statusRaw = data["status"] as? String {
               let cloudUpdated = (data["lastUpdated"] as? Timestamp)?.dateValue() ?? Date.distantPast
               if cloudUpdated > package.lastUpdated {
                   package.statusRawValue = statusRaw
                   package.lastUpdated = cloudUpdated
                   try? context.save()
                   print("[Sync] âœ… Updated package \(package.trackingNumber) from cloud")
               }
           }
       }
   }

   enum SyncError: LocalizedError {
       case notAuthenticated

       var errorDescription: String? {
           switch self {
           case .notAuthenticated:
               return String(localized: "sync.error.notAuthenticated")
           }
       }
   }
   ```

2. **å»ºç«‹ FirebasePushService.swift**
   ```swift
   import FirebaseMessaging
   import FirebaseFirestore

   @MainActor
   final class FirebasePushService: NSObject, ObservableObject {
       static let shared = FirebasePushService()

       @Published var fcmToken: String?

       private override init() {
           super.init()
           Messaging.messaging().delegate = self
       }

       // MARK: - è¨»å†Šæ¨æ’­

       func registerForPushNotifications() async {
           // 1. è«‹æ±‚ APNs æ¬Šé™
           let granted = await NotificationService.shared.requestAuthorization()
           guard granted else { return }

           // 2. è¨»å†Š APNs
           await UIApplication.shared.registerForRemoteNotifications()
       }

       // MARK: - ä¸Šå‚³ FCM Token åˆ° Firestore

       func uploadFCMToken() async throws {
           guard let userId = FirebaseAuthService.shared.currentUser?.uid,
                 let token = fcmToken else {
               return
           }

           let db = Firestore.firestore()
           let userRef = db.collection("users").document(userId)

           try await userRef.setData([
               "fcmToken": token,
               "lastActive": FieldValue.serverTimestamp()
           ], merge: true)

           print("[FCM] âœ… Token uploaded: \(token)")
       }
   }

   // MARK: - MessagingDelegate

   extension FirebasePushService: MessagingDelegate {
       nonisolated func messaging(
           _ messaging: Messaging,
           didReceiveRegistrationToken fcmToken: String?
       ) {
           Task { @MainActor in
               self.fcmToken = fcmToken
               print("[FCM] Received token: \(fcmToken ?? "nil")")

               // è‡ªå‹•ä¸Šå‚³åˆ° Firestore
               try? await self.uploadFCMToken()
           }
       }
   }
   ```

3. **ä¿®æ”¹ PackageTrakerApp.swiftï¼ˆæ–°å¢ FCM åˆå§‹åŒ–ï¼‰**
   ```swift
   init() {
       FirebaseApp.configure()
       UNUserNotificationCenter.current().delegate = NotificationDelegate.shared

       // è¨»å†Š FCM
       Task {
           await FirebasePushService.shared.registerForPushNotifications()
       }
   }

   var body: some Scene {
       WindowGroup {
           Group {
               if authService.isAuthenticated {
                   ZStack {
                       MainTabView()
                           .environment(refreshService)
                           .onAppear {
                               // é¦–æ¬¡ç™»å…¥æ™‚åŒæ­¥æœ¬åœ°è³‡æ–™
                               Task {
                                   await performInitialSync()
                               }

                               // ç›£è½ Firestore è®ŠåŒ–
                               FirebaseSyncService.shared.observePackageChanges(context: modelContext)
                           }

                       if showSplash {
                           SplashView(refreshService: refreshService) {
                               showSplash = false
                           }
                       }
                   }
               } else {
                   SignInView()
               }
           }
           .preferredColorScheme(.dark)
           .environmentObject(authService)
       }
       .modelContainer(for: [Package.self, TrackingEvent.self, LinkedEmailAccount.self])
   }

   private func performInitialSync() async {
       // æª¢æŸ¥æ˜¯å¦å·²åŒæ­¥é
       let hasSync = UserDefaults.standard.bool(forKey: "hasPerformedInitialSync_\(authService.currentUser?.uid ?? "")")
       if hasSync { return }

       // ä¸Šå‚³æ‰€æœ‰æœ¬åœ°åŒ…è£¹
       do {
           let context = ModelContext(modelContainer)
           try await FirebaseSyncService.shared.syncAllLocalPackages(context: context)

           // æ¨™è¨˜å·²åŒæ­¥
           UserDefaults.standard.set(true, forKey: "hasPerformedInitialSync_\(authService.currentUser?.uid ?? "")")
       } catch {
           print("[Sync] Initial sync failed: \(error)")
       }
   }
   ```

4. **ä¿®æ”¹ AppDelegateï¼ˆè™•ç† APNs Tokenï¼‰**
   ```swift
   class AppDelegate: NSObject, UIApplicationDelegate {
       func application(
           _ application: UIApplication,
           didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
       ) -> Bool {
           return true
       }

       // æ¥æ”¶ APNs Device Token
       func application(
           _ application: UIApplication,
           didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data
       ) {
           Messaging.messaging().apnsToken = deviceToken
       }

       // è¨»å†Šå¤±æ•—è™•ç†
       func application(
           _ application: UIApplication,
           didFailToRegisterForRemoteNotificationsWithError error: Error
       ) {
           print("[APNs] Failed to register: \(error.localizedDescription)")
       }
   }
   ```

5. **ä¿®æ”¹ AddPackageView.swiftï¼ˆæ–°å¢åŒ…è£¹æ™‚åŒæ­¥ï¼‰**
   ```swift
   private func savePackage() {
       let newPackage = Package(
           trackingNumber: trackingNumber,
           carrier: selectedCarrier,
           customName: customName.isEmpty ? nil : customName,
           // ... å…¶ä»–æ¬„ä½
       )

       context.insert(newPackage)
       try? context.save()

       // åŒæ­¥åˆ° Firestore
       Task {
           do {
               try await FirebaseSyncService.shared.syncPackageToCloud(newPackage)
               print("[Sync] âœ… New package synced to cloud")
           } catch {
               print("[Sync] Failed to sync new package: \(error)")
           }
       }

       // è¿”å›ä¸Šä¸€é 
       dismiss()
   }
   ```

6. **ä¿®æ”¹ PackageRefreshService.swiftï¼ˆåˆ·æ–°å¾ŒåŒæ­¥ï¼‰**
   ```swift
   private func applyTrackingResult(_ result: TrackingResult, to package: Package) {
       // ... åŸæœ‰çš„æ›´æ–°é‚è¼¯ ...

       // åŒæ­¥åˆ° Firestore
       Task {
           try? await FirebaseSyncService.shared.syncPackageToCloud(package)
       }
   }
   ```

#### é©—è­‰æ–¹æ³•
```bash
# 1. ç™»å…¥ App
# 2. æ–°å¢ä¸€å€‹åŒ…è£¹
# 3. æª¢æŸ¥ Firestore Console:
#    - /users/{userId}/packages/{packageId} æ˜¯å¦æœ‰è³‡æ–™
# 4. ä¿®æ”¹ Firestore åŒ…è£¹ç‹€æ…‹ï¼ˆæ‰‹å‹•ï¼‰
# 5. ç¢ºèª iOS ç«¯è‡ªå‹•æ›´æ–°
# 6. æª¢æŸ¥ Firestore Console:
#    - /users/{userId}/fcmToken æ˜¯å¦æœ‰å€¼
```

---

### Phase 3: Cloud Functions å¾Œç«¯å¯¦ä½œ (3-4 å¤©)

#### ç›®æ¨™
å»ºç«‹å¾Œç«¯å®šæ™‚è¼ªè©¢ã€ç‹€æ…‹è®ŠåŒ–åµæ¸¬ã€æ¨æ’­ç™¼é€é‚è¼¯ã€‚

#### é—œéµæª”æ¡ˆ

**æ–°å¢æª”æ¡ˆï¼ˆå¾Œç«¯ï¼‰ï¼š**
- `functions/src/index.ts` - Functions å…¥å£
- `functions/src/scheduler.ts` - å®šæ™‚è¼ªè©¢é‚è¼¯
- `functions/src/triggers.ts` - Firestore Trigger
- `functions/src/services/trackTwApi.ts` - Track.TW API å°è£
- `functions/src/services/pushNotification.ts` - æ¨æ’­æœå‹™
- `functions/src/utils/statusMapper.ts` - ç‹€æ…‹æ˜ å°„
- `functions/.env.local` - æœ¬åœ°ç’°å¢ƒè®Šæ•¸
- `functions/package.json` - Node.js ä¾è³´

#### å¯¦ä½œæ­¥é©Ÿ

1. **åˆå§‹åŒ– Firebase Functions å°ˆæ¡ˆ**
   ```bash
   # åœ¨å°ˆæ¡ˆæ ¹ç›®éŒ„
   cd /Users/jonathanyu/Desktop/Side\ Project/Swift/PackageTraker

   # å®‰è£ Firebase CLI
   npm install -g firebase-tools

   # ç™»å…¥ Firebase
   firebase login

   # åˆå§‹åŒ– Functions
   firebase init functions
   # é¸æ“‡ï¼š
   # - Use existing project: PackageTraker
   # - Language: TypeScript
   # - ESLint: Yes
   # - Install dependencies: Yes
   ```

2. **è¨­å®šç’°å¢ƒè®Šæ•¸**
   ```bash
   # è¨­å®š Track.TW Tokenï¼ˆå¾ Secrets.swift è¤‡è£½ï¼‰
   firebase functions:config:set trackw.token="NLJSJMlCsAo04wXW6dLaE6zYrdljgwRwyN3zieubae442f0a"

   # æœ¬åœ°æ¸¬è©¦ç”¨ï¼ˆå»ºç«‹ .env.localï¼‰
   cd functions
   echo 'TRACKW_TOKEN="NLJSJMlCsAo04wXW6dLaE6zYrdljgwRwyN3zieubae442f0a"' > .env.local
   ```

3. **å®‰è£ä¾è³´**
   ```bash
   cd functions
   npm install axios
   npm install --save-dev @types/node
   ```

4. **å»ºç«‹ src/services/trackTwApi.ts**
   ```typescript
   import axios, { AxiosInstance } from 'axios';

   const BASE_URL = 'https://track.tw/api/v1';

   export interface TrackTwCheckpoint {
     packageId: string;
     time: number;  // Unix timestamp
     status: string;  // ä¸­æ–‡æè¿°
     checkpointStatus: 'pending' | 'transit' | 'delivered' | 'exception';
     createdAt: string;
   }

   export interface TrackTwTrackingResponse {
     id: string;
     trackingNumber: string;
     carrierId: string;
     packageHistory: TrackTwCheckpoint[];
     storeName?: string;
   }

   export class TrackTwAPI {
     private client: AxiosInstance;

     constructor(token: string) {
       this.client = axios.create({
         baseURL: BASE_URL,
         headers: {
           'Authorization': `Bearer ${token}`,
           'Content-Type': 'application/json',
         },
         timeout: 10000,
       });
     }

     async getTracking(relationId: string): Promise<TrackTwTrackingResponse> {
       try {
         const response = await this.client.get(`/package/tracking/${relationId}`);
         return response.data;
       } catch (error: any) {
         if (error.response?.status === 404) {
           throw new Error(`Package not found: ${relationId}`);
         }
         throw error;
       }
     }

     async importPackage(carrierId: string, trackingNumbers: string[]): Promise<Record<string, string>> {
       const response = await this.client.post('/package/import', {
         carrier: carrierId,
         tracking_numbers: trackingNumbers,
         notify_state: 'on',
       });
       return response.data;
     }
   }
   ```

5. **å»ºç«‹ src/utils/statusMapper.ts**
   ```typescript
   // æ˜ å°„ Track.TW ç‹€æ…‹åˆ° App ç‹€æ…‹
   export function mapTrackTwStatus(
     checkpointStatus: string,
     description: string
   ): string {
     switch (checkpointStatus) {
       case 'delivered':
         return 'delivered';

       case 'exception':
         if (description.includes('é€€å›') || description.includes('é€€è²¨')) {
           return 'returned';
         }
         return 'returned';

       case 'pending':
         return 'pending';

       case 'transit':
         // åˆ°è²¨åˆ¤æ–·
         if (
           description.includes('åˆ°åº—') ||
           description.includes('åˆ°é–€å¸‚') ||
           description.includes('å¾…å–') ||
           description.includes('å¯å–è²¨') ||
           description.includes('é…é”å®Œæˆ')
         ) {
           return 'arrivedAtStore';
         }

         // é…é€ä¸­åˆ¤æ–·
         if (
           description.includes('é…é€ä¸­') ||
           description.includes('é‹é€ä¸­') ||
           description.includes('è½‰é‹')
         ) {
           return 'inTransit';
         }

         // å·²å‡ºè²¨åˆ¤æ–·
         if (
           description.includes('å¯„ä»¶') ||
           description.includes('å‡ºè²¨') ||
           description.includes('å·²æ”¶ä»¶')
         ) {
           return 'shipped';
         }

         return 'inTransit';

       default:
         return 'pending';
     }
   }
   ```

6. **å»ºç«‹ src/services/pushNotification.ts**
   ```typescript
   import * as admin from 'firebase-admin';

   export interface PushPayload {
     title: string;
     body: string;
     data?: Record<string, string>;
   }

   export async function sendPushNotification(
     fcmToken: string,
     payload: PushPayload
   ): Promise<void> {
     const message: admin.messaging.Message = {
       token: fcmToken,
       notification: {
         title: payload.title,
         body: payload.body,
       },
       data: payload.data || {},
       apns: {
         headers: {
           'apns-priority': '10',
         },
         payload: {
           aps: {
             sound: 'default',
             badge: 1,
             'content-available': 1,  // å…è¨±èƒŒæ™¯æ›´æ–°
           },
         },
       },
     };

     try {
       const response = await admin.messaging().send(message);
       console.log(`âœ… Push notification sent: ${response}`);
     } catch (error) {
       console.error('âŒ Failed to send push notification:', error);
       throw error;
     }
   }
   ```

7. **å»ºç«‹ src/scheduler.tsï¼ˆæ ¸å¿ƒè¼ªè©¢é‚è¼¯ï¼‰**
   ```typescript
   import * as functions from 'firebase-functions';
   import * as admin from 'firebase-admin';
   import { TrackTwAPI } from './services/trackTwApi';
   import { mapTrackTwStatus } from './utils/statusMapper';

   const db = admin.firestore();

   // æ¯ 15 åˆ†é˜åŸ·è¡Œä¸€æ¬¡
   export const packageTrackingScheduler = functions
     .runWith({
       timeoutSeconds: 540,  // 9 åˆ†é˜ timeout
       memory: '512MB',
     })
     .pubsub
     .schedule('*/15 * * * *')  // Cron: æ¯ 15 åˆ†é˜
     .timeZone('Asia/Taipei')
     .onRun(async (context) => {
       console.log('ğŸ”„ [Scheduler] Starting package tracking poll...');

       const trackwToken = functions.config().trackw.token;
       if (!trackwToken) {
         console.error('âŒ Track.TW token not configured');
         return null;
       }

       const api = new TrackTwAPI(trackwToken);

       // 1. å–å¾—æ‰€æœ‰ç”¨æˆ¶
       const usersSnapshot = await db.collection('users').get();
       console.log(`ğŸ“¦ Found ${usersSnapshot.size} users`);

       let totalProcessed = 0;
       let totalUpdated = 0;

       // 2. é€ç”¨æˆ¶è™•ç†
       for (const userDoc of usersSnapshot.docs) {
         const userId = userDoc.id;

         // å–å¾—è©²ç”¨æˆ¶çš„æ‰€æœ‰æœªå®ŒæˆåŒ…è£¹
         const packagesSnapshot = await db
           .collection(`users/${userId}/packages`)
           .where('isArchived', '==', false)
           .where('status', 'not-in', ['delivered', 'returned'])
           .get();

         console.log(`ğŸ‘¤ User ${userId}: ${packagesSnapshot.size} active packages`);

         // 3. é€åŒ…è£¹è¿½è¹¤
         for (const packageDoc of packagesSnapshot.docs) {
           const pkg = packageDoc.data();
           const packageId = packageDoc.id;

           if (!pkg.trackTwRelationId) {
             console.log(`â­ï¸  Skip ${pkg.trackingNumber}: no relationId`);
             continue;
           }

           try {
             // å‘¼å« Track.TW API
             const tracking = await api.getTracking(pkg.trackTwRelationId);

             if (!tracking.packageHistory || tracking.packageHistory.length === 0) {
               console.log(`â­ï¸  Skip ${pkg.trackingNumber}: no history`);
               continue;
             }

             // å–å¾—æœ€æ–°ç‹€æ…‹
             const latestCheckpoint = tracking.packageHistory[0];
             const newStatus = mapTrackTwStatus(
               latestCheckpoint.checkpointStatus,
               latestCheckpoint.status
             );
             const oldStatus = pkg.status;

             totalProcessed++;

             // 4. ç‹€æ…‹è®ŠåŒ–æ™‚æ›´æ–°
             if (newStatus !== oldStatus) {
               console.log(`ğŸ”„ ${pkg.trackingNumber}: ${oldStatus} â†’ ${newStatus}`);

               await packageDoc.ref.update({
                 status: newStatus,
                 lastUpdated: admin.firestore.FieldValue.serverTimestamp(),
                 storeName: tracking.storeName || pkg.storeName || '',
               });

               totalUpdated++;
             }

           } catch (error: any) {
             console.error(`âŒ Failed to track ${pkg.trackingNumber}:`, error.message);
           }

           // é¿å… API rate limitï¼ˆæ¯å€‹è«‹æ±‚é–“éš” 100msï¼‰
           await new Promise(resolve => setTimeout(resolve, 100));
         }
       }

       console.log(`âœ… [Scheduler] Completed: ${totalProcessed} processed, ${totalUpdated} updated`);
       return null;
     });
   ```

8. **å»ºç«‹ src/triggers.tsï¼ˆç‹€æ…‹è®ŠåŒ–æ¨æ’­ï¼‰**
   ```typescript
   import * as functions from 'firebase-functions';
   import * as admin from 'firebase-admin';
   import { sendPushNotification } from './services/pushNotification';

   const db = admin.firestore();

   // ç›£è½åŒ…è£¹ç‹€æ…‹è®ŠåŒ–
   export const onPackageStatusChange = functions.firestore
     .document('users/{userId}/packages/{packageId}')
     .onUpdate(async (change, context) => {
       const before = change.before.data();
       const after = change.after.data();
       const userId = context.params.userId;
       const packageId = context.params.packageId;

       // ç‹€æ…‹æœªè®ŠåŒ–ï¼Œè·³é
       if (before.status === after.status) {
         return null;
       }

       console.log(`ğŸ“¦ Status changed: ${after.trackingNumber} (${before.status} â†’ ${after.status})`);

       // å–å¾—ç”¨æˆ¶è³‡æ–™
       const userDoc = await db.collection('users').doc(userId).get();
       const userData = userDoc.data();

       if (!userData || !userData.fcmToken) {
         console.log('â­ï¸  Skip: no FCM token');
         return null;
       }

       // æª¢æŸ¥é€šçŸ¥è¨­å®š
       if (!userData.notificationSettings?.enabled) {
         console.log('â­ï¸  Skip: notifications disabled');
         return null;
       }

       // é¿å…é‡è¤‡æ¨æ’­
       if (before.lastNotifiedStatus === after.status) {
         console.log('â­ï¸  Skip: already notified for this status');
         return null;
       }

       // åªåœ¨åˆ°è²¨æ™‚æ¨æ’­
       if (after.status === 'arrivedAtStore' && before.status !== 'arrivedAtStore') {
         const packageName = after.customName || after.trackingNumber;
         const location = after.pickupLocation || after.storeName || 'å–è²¨åœ°é»';

         try {
           await sendPushNotification(userData.fcmToken, {
             title: 'ğŸ“¦ åŒ…è£¹å·²åˆ°é”å–è²¨é»',
             body: `${packageName} å·²åˆ°é” ${location}ï¼Œè«‹å„˜å¿«å–è²¨`,
             data: {
               packageId: packageId,
               trackingNumber: after.trackingNumber,
               status: after.status,
             },
           });

           // æ›´æ–° lastNotifiedStatus
           await change.after.ref.update({
             lastNotifiedStatus: after.status,
           });

           console.log(`âœ… Push sent to ${userId}`);
         } catch (error) {
           console.error('âŒ Failed to send push:', error);
         }
       }

       return null;
     });
   ```

9. **å»ºç«‹ src/index.tsï¼ˆå…¥å£ï¼‰**
   ```typescript
   import * as admin from 'firebase-admin';

   // åˆå§‹åŒ– Firebase Admin SDK
   admin.initializeApp();

   // åŒ¯å‡ºæ‰€æœ‰ Functions
   export { packageTrackingScheduler } from './scheduler';
   export { onPackageStatusChange } from './triggers';
   ```

10. **éƒ¨ç½² Cloud Functions**
    ```bash
    cd functions

    # ç·¨è­¯ TypeScript
    npm run build

    # éƒ¨ç½²åˆ° Firebase
    firebase deploy --only functions

    # æŸ¥çœ‹éƒ¨ç½²ç‹€æ…‹
    firebase functions:log
    ```

#### é©—è­‰æ–¹æ³•
```bash
# 1. éƒ¨ç½²æˆåŠŸå¾Œï¼Œå‰å¾€ Firebase Console > Functions
# 2. ç¢ºèªçœ‹åˆ° 2 å€‹å‡½æ•¸ï¼š
#    - packageTrackingScheduler
#    - onPackageStatusChange
# 3. ç­‰å¾… 15 åˆ†é˜ï¼ŒæŸ¥çœ‹ Logs ç¢ºèªå®šæ™‚ä»»å‹™åŸ·è¡Œ
# 4. æ‰‹å‹•ä¿®æ”¹ Firestore åŒ…è£¹ç‹€æ…‹ç‚º "arrivedAtStore"
# 5. ç¢ºèª iOS è¨­å‚™æ”¶åˆ°æ¨æ’­é€šçŸ¥
```

---

### Phase 4: Deep Link èˆ‡ UI å„ªåŒ– (1-2 å¤©)

#### ç›®æ¨™
å¯¦ç¾é€šçŸ¥é»æ“Šå¾Œè·³è½‰åˆ°åŒ…è£¹è©³æƒ…é ã€å„ªåŒ– UI é«”é©—ã€‚

#### é—œéµæª”æ¡ˆ

**ä¿®æ”¹æª”æ¡ˆï¼š**
- `PackageTraker/Services/Notification/NotificationDelegate.swift` - è™•ç†é€šçŸ¥é»æ“Š
- `PackageTraker/Views/MainTabView.swift` - Deep Link å°èˆª
- `PackageTraker/Views/Settings/SettingsView.swift` - ç™»å‡ºåŠŸèƒ½

#### å¯¦ä½œæ­¥é©Ÿ

1. **ä¿®æ”¹ NotificationDelegate.swift**
   ```swift
   class NotificationDelegate: NSObject, UNUserNotificationCenterDelegate {
       static let shared = NotificationDelegate()

       // å‰æ™¯é€šçŸ¥é¡¯ç¤º
       func userNotificationCenter(
           _ center: UNUserNotificationCenter,
           willPresent notification: UNNotification,
           withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void
       ) {
           completionHandler([.banner, .sound, .badge])
       }

       // é»æ“Šé€šçŸ¥è™•ç†
       func userNotificationCenter(
           _ center: UNUserNotificationCenter,
           didReceive response: UNNotificationResponse,
           withCompletionHandler completionHandler: @escaping () -> Void
       ) {
           let userInfo = response.notification.request.content.userInfo

           // å–å¾— packageId
           if let packageId = userInfo["packageId"] as? String {
               // ç™¼é€é€šçŸ¥çµ¦ MainTabView
               NotificationCenter.default.post(
                   name: .navigateToPackageDetail,
                   object: nil,
                   userInfo: ["packageId": packageId]
               )
           }

           completionHandler()
       }
   }

   // è‡ªå®šç¾©é€šçŸ¥åç¨±
   extension Notification.Name {
       static let navigateToPackageDetail = Notification.Name("navigateToPackageDetail")
   }
   ```

2. **ä¿®æ”¹ MainTabView.swiftï¼ˆDeep Link å°èˆªï¼‰**
   ```swift
   struct MainTabView: View {
       @State private var selectedTab = 0
       @State private var navigationPath = NavigationPath()
       @State private var selectedPackageId: String?

       var body: some View {
           TabView(selection: $selectedTab) {
               NavigationStack(path: $navigationPath) {
                   PackageListView()
                       .navigationDestination(for: String.self) { packageId in
                           if let package = findPackage(by: packageId) {
                               PackageDetailView(package: package)
                           }
                       }
               }
               .tabItem {
                   Label("åŒ…è£¹åˆ—è¡¨", systemImage: "shippingbox.fill")
               }
               .tag(0)

               // å…¶ä»– tabs...
           }
           .onAppear {
               // ç›£è½æ¨æ’­é»æ“Šäº‹ä»¶
               NotificationCenter.default.addObserver(
                   forName: .navigateToPackageDetail,
                   object: nil,
                   queue: .main
               ) { notification in
                   if let packageId = notification.userInfo?["packageId"] as? String {
                       handleDeepLink(packageId: packageId)
                   }
               }
           }
       }

       private func handleDeepLink(packageId: String) {
           // åˆ‡æ›åˆ°åŒ…è£¹åˆ—è¡¨ tab
           selectedTab = 0

           // å°èˆªåˆ°è©³æƒ…é 
           DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
               navigationPath.append(packageId)
           }
       }

       @MainActor
       private func findPackage(by id: String) -> Package? {
           guard let uuid = UUID(uuidString: id) else { return nil }

           let context = ModelContext(...)
           let descriptor = FetchDescriptor<Package>(
               predicate: #Predicate { $0.id == uuid }
           )
           return try? context.fetch(descriptor).first
       }
   }
   ```

3. **ä¿®æ”¹ SettingsView.swiftï¼ˆæ–°å¢ç™»å‡ºåŠŸèƒ½ï¼‰**
   ```swift
   struct SettingsView: View {
       @EnvironmentObject private var authService: FirebaseAuthService
       @State private var showSignOutAlert = false

       var body: some View {
           ScrollView {
               VStack(spacing: 24) {
                   // ... ç¾æœ‰è¨­å®š ...

                   // å¸³è™Ÿå€å¡Š
                   accountSection
               }
           }
           .alert("ç¢ºèªç™»å‡º", isPresented: $showSignOutAlert) {
               Button("å–æ¶ˆ", role: .cancel) {}
               Button("ç™»å‡º", role: .destructive) {
                   signOut()
               }
           } message: {
               Text("ç™»å‡ºå¾Œå°‡åœæ­¢æ¨æ’­é€šçŸ¥ï¼Œæœ¬åœ°è³‡æ–™å°‡ä¿ç•™ã€‚")
           }
       }

       private var accountSection: some View {
           VStack(alignment: .leading, spacing: 12) {
               Text("å¸³è™Ÿ")
                   .font(.title2)
                   .fontWeight(.bold)

               VStack(spacing: 0) {
                   // Apple ID é¡¯ç¤º
                   HStack {
                       Image(systemName: "person.circle.fill")
                           .font(.system(size: 18))
                           .foregroundStyle(.green)

                       Text(authService.currentUser?.email ?? "Apple ID")
                           .foregroundStyle(.white)

                       Spacer()
                   }
                   .padding(16)
                   .background(Color.secondaryCardBackground)

                   Divider()

                   // ç™»å‡ºæŒ‰éˆ•
                   Button {
                       showSignOutAlert = true
                   } label: {
                       HStack {
                           Image(systemName: "rectangle.portrait.and.arrow.right")
                               .font(.system(size: 18))
                               .foregroundStyle(.red)

                           Text("ç™»å‡º")
                               .foregroundStyle(.red)

                           Spacer()
                       }
                       .padding(16)
                       .background(Color.secondaryCardBackground)
                   }
               }
               .clipShape(RoundedRectangle(cornerRadius: 16))
           }
       }

       private func signOut() {
           do {
               // åœæ­¢ç›£è½ Firestore
               FirebaseSyncService.shared.stopObserving()

               // ç™»å‡º Firebase
               try authService.signOut()

               // æ¸…é™¤åŒæ­¥æ¨™è¨˜
               if let userId = authService.currentUser?.uid {
                   UserDefaults.standard.removeObject(forKey: "hasPerformedInitialSync_\(userId)")
               }
           } catch {
               print("Sign out failed: \(error)")
           }
       }
   }
   ```

4. **æ–°å¢æœ¬åœ°åŒ–å­—ä¸²**
   ```strings
   // zh-Hant.lproj/Localizable.strings
   "sync.error.notAuthenticated" = "è«‹å…ˆç™»å…¥";
   "settings.account" = "å¸³è™Ÿ";
   "settings.signOut" = "ç™»å‡º";
   "settings.signOutConfirm.title" = "ç¢ºèªç™»å‡º";
   "settings.signOutConfirm.message" = "ç™»å‡ºå¾Œå°‡åœæ­¢æ¨æ’­é€šçŸ¥ï¼Œæœ¬åœ°è³‡æ–™å°‡ä¿ç•™ã€‚";
   ```

#### é©—è­‰æ–¹æ³•
```bash
# 1. ç™¼é€æ¸¬è©¦æ¨æ’­ï¼ˆFirebase Console > Cloud Messagingï¼‰
# 2. é»æ“Šæ¨æ’­é€šçŸ¥
# 3. ç¢ºèª App è‡ªå‹•è·³è½‰åˆ°å°æ‡‰åŒ…è£¹è©³æƒ…é 
# 4. æ¸¬è©¦ç™»å‡ºåŠŸèƒ½
# 5. ç¢ºèªç™»å‡ºå¾Œæ¨æ’­åœæ­¢
```

---

## è³‡æ–™æµç¨‹åœ–

### å®Œæ•´è³‡æ–™æµ

```
ç”¨æˆ¶æ–°å¢åŒ…è£¹
    â†“
â‘  iOS: å„²å­˜åˆ° SwiftData
    â†“
â‘¡ iOS: syncPackageToCloud()
    â†“
â‘¢ Firestore: /users/{userId}/packages/{packageId}
    â†“
â° æ¯ 15 åˆ†é˜
    â†“
â‘£ Cloud Scheduler è§¸ç™¼ packageTrackingScheduler
    â†“
â‘¤ Cloud Function: æŸ¥è©¢æ‰€æœ‰æœªå®ŒæˆåŒ…è£¹
    â†“
â‘¥ Cloud Function: å‘¼å« Track.TW API
    â†“
â‘¦ Cloud Function: æ¯”å°ç‹€æ…‹è®ŠåŒ–
    â†“
â‘§ Cloud Function: æ›´æ–° Firestore (status)
    â†“
â‘¨ Firestore Trigger: onPackageStatusChange
    â†“
â‘© ç‹€æ…‹ = "arrivedAtStore" ?
    â”œâ”€ Yes â†’ ç™¼é€ FCM æ¨æ’­
    â””â”€ No  â†’ è·³é
    â†“
â‘ª APNs è½‰ç™¼æ¨æ’­åˆ° iOS è¨­å‚™
    â†“
â‘« iOS: é¡¯ç¤ºé€šçŸ¥ banner
    â†“
â‘¬ ç”¨æˆ¶é»æ“Šé€šçŸ¥
    â†“
â‘­ iOS: Deep Link åˆ° PackageDetailView
```

---

## æˆæœ¬ä¼°ç®—ï¼ˆFirebase Free Tierï¼‰

### ç”¨é‡é ä¼°ï¼ˆ100 ç”¨æˆ¶ï¼Œæ¯äºº 5 åŒ…è£¹ï¼‰

| æœå‹™ | ä¼°ç®—ç”¨é‡ | å…è²»é¡åº¦ | æ˜¯å¦å……è¶³ |
|------|----------|----------|----------|
| **Firestore è®€å–** | 500 packages Ã— 96 æ¬¡/å¤© = 48,000 reads/day | 50,000 reads/day | âœ… 96% |
| **Firestore å¯«å…¥** | 500 packages Ã— 10 æ¬¡/å¤© = 5,000 writes/day | 20,000 writes/day | âœ… 25% |
| **Firestore å„²å­˜** | 500 packages Ã— 2KB + 2,000 events Ã— 500B = 2MB | 1GB | âœ… 0.2% |
| **Cloud Functions èª¿ç”¨** | 96 æ¬¡/å¤© Ã— 30 å¤© = 2,880 invocations/month | 2,000,000/month | âœ… 0.14% |
| **Cloud Functions åŸ·è¡Œæ™‚é–“** | 96 æ¬¡ Ã— 3 ç§’ = 288 ç§’/å¤© Ã— 30 = 8,640 ç§’/æœˆ | 400,000 ç§’/æœˆ | âœ… 2.16% |
| **FCM æ¨æ’­** | ç´„ 100 é€šçŸ¥/å¤© = 3,000/æœˆ | ç„¡é™åˆ¶ | âœ… å…è²» |
| **Cloud Scheduler** | 1 job Ã— 96 æ¬¡/å¤© | 3 jobs å…è²» | âœ… å……è£• |

### çµè«–
- 100 ç”¨æˆ¶è¦æ¨¡å®Œå…¨åœ¨å…è²»é¡åº¦å…§
- å¯æ”¯æ´è‡³å°‘ **1,000 ç”¨æˆ¶**ä»åœ¨å…è²»é¡åº¦
- è¶…éå¾Œæˆæœ¬æ¥µä½ï¼ˆæ¯æœˆç´„ $5-10 USDï¼‰

---

## é—œéµæ–‡ä»¶æ¸…å–®

### iOS ç«¯ï¼ˆæ–°å¢ï¼‰
- `PackageTraker/GoogleService-Info.plist`
- `PackageTraker/Services/Firebase/FirebaseAuthService.swift`
- `PackageTraker/Services/Firebase/FirebaseSyncService.swift`
- `PackageTraker/Services/Firebase/FirebasePushService.swift`
- `PackageTraker/Views/Auth/SignInView.swift`
- `PackageTraker/PackageTraker.entitlements`

### iOS ç«¯ï¼ˆä¿®æ”¹ï¼‰
- `PackageTraker/PackageTrakerApp.swift`
- `PackageTraker/Services/PackageRefreshService.swift`
- `PackageTraker/Services/Notification/NotificationDelegate.swift`
- `PackageTraker/Views/AddPackage/AddPackageView.swift`
- `PackageTraker/Views/Settings/SettingsView.swift`
- `PackageTraker/Info.plist`
- `Package.swift` (SPM ä¾è³´)

### å¾Œç«¯ï¼ˆæ–°å¢ï¼‰
- `functions/src/index.ts`
- `functions/src/scheduler.ts`
- `functions/src/triggers.ts`
- `functions/src/services/trackTwApi.ts`
- `functions/src/services/pushNotification.ts`
- `functions/src/utils/statusMapper.ts`
- `functions/package.json`
- `functions/.env.local`

---

## æ¸¬è©¦é©—è­‰è¨ˆåŠƒ

### Phase 1 æ¸¬è©¦
- [ ] Firebase å°ˆæ¡ˆå»ºç«‹æˆåŠŸ
- [ ] Apple Sign In ç™»å…¥æˆåŠŸ
- [ ] Firestore `/users/{userId}` å»ºç«‹æˆåŠŸ
- [ ] ç™»å‡ºåŠŸèƒ½æ­£å¸¸

### Phase 2 æ¸¬è©¦
- [ ] æ–°å¢åŒ…è£¹å¾Œ Firestore è‡ªå‹•åŒæ­¥
- [ ] ä¿®æ”¹ Firestore è³‡æ–™å¾Œ iOS è‡ªå‹•æ›´æ–°
- [ ] FCM Token æˆåŠŸä¸Šå‚³åˆ° Firestore
- [ ] é¦–æ¬¡ç™»å…¥æœ¬åœ°è³‡æ–™è‡ªå‹•é·ç§»

### Phase 3 æ¸¬è©¦
- [ ] Cloud Functions éƒ¨ç½²æˆåŠŸ
- [ ] å®šæ™‚ä»»å‹™æ¯ 15 åˆ†é˜åŸ·è¡Œ
- [ ] ç‹€æ…‹è®ŠåŒ–æ™‚ Firestore è‡ªå‹•æ›´æ–°
- [ ] æ‰‹å‹•ä¿®æ”¹ç‹€æ…‹ç‚º "arrivedAtStore" æ”¶åˆ°æ¨æ’­
- [ ] æ¨æ’­å…§å®¹æ­£ç¢ºï¼ˆåŒ…å«åŒ…è£¹åç¨±ã€åœ°é»ï¼‰

### Phase 4 æ¸¬è©¦
- [ ] é»æ“Šæ¨æ’­é€šçŸ¥è·³è½‰åˆ°è©³æƒ…é 
- [ ] å‰æ™¯é€šçŸ¥é¡¯ç¤º banner
- [ ] èƒŒæ™¯é€šçŸ¥æ­£å¸¸æ¥æ”¶
- [ ] App é—œé–‰æ™‚ä»æ”¶åˆ°æ¨æ’­
- [ ] ç™»å‡ºå¾Œæ¨æ’­åœæ­¢

---

## é¢¨éšªèˆ‡é™ç´šæ–¹æ¡ˆ

### é¢¨éšª 1: Firebase Free Tier è¶…é¡
**é™ç´šæ–¹æ¡ˆ**:
- èª¿æ•´è¼ªè©¢é »ç‡ï¼ˆ15 åˆ†é˜ â†’ 30 åˆ†é˜ï¼‰
- åƒ…è¿½è¹¤æœªåˆ°è²¨åŒ…è£¹
- å‡ç´šåˆ° Blaze è¨ˆåŠƒï¼ˆç”¨å¤šå°‘ä»˜å¤šå°‘ï¼‰

### é¢¨éšª 2: Track.TW API Rate Limit
**é™ç´šæ–¹æ¡ˆ**:
- æ¯å€‹ API è«‹æ±‚é–“éš” 100-200ms
- å–®æ¬¡æœ€å¤šè¿½è¹¤ 100 å€‹åŒ…è£¹
- éŒ¯èª¤æ™‚æŒ‡æ•¸é€€é¿é‡è©¦

### é¢¨éšª 3: APNs æ¨æ’­å¤±æ•—
**é™ç´šæ–¹æ¡ˆ**:
- æœ¬åœ°é€šçŸ¥ä½œç‚º fallbackï¼ˆApp å‰æ™¯æ™‚ï¼‰
- è¨˜éŒ„å¤±æ•—æ—¥èªŒä¸¦é‡è©¦
- é€šçŸ¥ç”¨æˆ¶æª¢æŸ¥é€šçŸ¥æ¬Šé™

### é¢¨éšª 4: Firestore åŒæ­¥è¡çª
**é™ç´šæ–¹æ¡ˆ**:
- Last Write Winsï¼ˆä½¿ç”¨ timestamp æ¯”å°ï¼‰
- æœ¬åœ° SwiftData ä½œç‚º Single Source of Truth
- è¡çªæ™‚å„ªå…ˆä¿ç•™æœ¬åœ°è³‡æ–™

---

## é–‹ç™¼æ™‚é–“é ä¼°

| éšæ®µ | æ™‚é–“ | é–‹ç™¼è€…æŠ€èƒ½éœ€æ±‚ | é¢¨éšªç­‰ç´š |
|------|------|---------------|---------|
| Phase 1: Firebase + Apple Sign In | 2-3 å¤© | iOS (SwiftUI, Firebase) | ä¸­ï¼ˆApple æ†‘è­‰è¨­å®šï¼‰ |
| Phase 2: Firestore åŒæ­¥ + FCM | 3-4 å¤© | iOS (SwiftUI, Firestore) | ä¸­ï¼ˆé›™å‘åŒæ­¥é‚è¼¯ï¼‰ |
| Phase 3: Cloud Functions | 3-4 å¤© | Backend (TypeScript, Firebase) | ä¸­ï¼ˆTrack.TW API æ•´åˆï¼‰ |
| Phase 4: Deep Link + UI | 1-2 å¤© | iOS (SwiftUI) | ä½ |
| **ç¸½è¨ˆ** | **9-13 å¤©** | å–®äººå…¨ç«¯é–‹ç™¼ | - |

---

## å¾ŒçºŒå„ªåŒ–æ–¹å‘

### çŸ­æœŸï¼ˆ1-2 å€‹æœˆï¼‰
1. **Widget æ”¯æ´**ï¼šiOS æ¡Œé¢å°å·¥å…·é¡¯ç¤ºåŒ…è£¹ç‹€æ…‹
2. **æ¯æ—¥å–è²¨æé†’**ï¼šæ—©ä¸Š 10:00 æé†’å¾…å–åŒ…è£¹
3. **æ¨æ’­å…§å®¹è±å¯ŒåŒ–**ï¼šåŒ…å«å–è²¨ç¢¼ã€åœ°åœ–é€£çµ

### ä¸­æœŸï¼ˆ3-6 å€‹æœˆï¼‰
1. **å¤šè¨­å‚™åŒæ­¥**ï¼šiPad/Mac æ”¯æ´
2. **å®¶åº­å…±äº«**ï¼šèˆ‡å®¶äººå…±äº«åŒ…è£¹è³‡è¨Š
3. **Analytics**ï¼šè¿½è¹¤ç”¨æˆ¶è¡Œç‚ºå„ªåŒ–é«”é©—

### é•·æœŸï¼ˆ6-12 å€‹æœˆï¼‰
1. **Android ç‰ˆæœ¬**ï¼šReact Native æˆ– Flutter é‡å¯«
2. **Web ç‰ˆæœ¬**ï¼šç€è¦½å™¨å­˜å–
3. **AI é æ¸¬**ï¼šé æ¸¬åˆ°è²¨æ™‚é–“

---

## é™„éŒ„

### A. Firebase Console æ“ä½œæŒ‡å—

```bash
# 1. å»ºç«‹å°ˆæ¡ˆ
https://console.firebase.google.com/ â†’ æ–°å¢å°ˆæ¡ˆ

# 2. è¨­å®š iOS App
å°ˆæ¡ˆè¨­å®š â†’ æ–°å¢æ‡‰ç”¨ç¨‹å¼ â†’ iOS
Bundle ID: com.yourname.PackageTraker
ä¸‹è¼‰ GoogleService-Info.plist

# 3. å•Ÿç”¨æœå‹™
Authentication â†’ Sign-in method â†’ Apple (å•Ÿç”¨)
Firestore Database â†’ å»ºç«‹è³‡æ–™åº« â†’ æ¸¬è©¦æ¨¡å¼
Cloud Functions â†’ å‡ç´šåˆ° Blaze è¨ˆåŠƒï¼ˆåƒ…ä»˜è²»ä½¿ç”¨ï¼‰
Cloud Messaging â†’ ä¸Šå‚³ APNs Key

# 4. è¨­å®š Security Rules
Firestore â†’ Rules â†’ è²¼ä¸Šä¸Šè¿° rules
```

### B. Apple Developer Console æ“ä½œæŒ‡å—

```bash
# 1. å•Ÿç”¨ Sign in with Apple
https://developer.apple.com/account/
Identifiers â†’ App IDs â†’ ä½ çš„ App ID
Capabilities â†’ Sign in with Apple (å‹¾é¸)

# 2. å»ºç«‹ APNs Key
Keys â†’ + â†’ Apple Push Notifications service (APNs)
ä¸‹è¼‰ .p8 æª”æ¡ˆ
è¨˜éŒ„ Key ID å’Œ Team ID

# 3. ä¸Šå‚³åˆ° Firebase
Firebase Console â†’ å°ˆæ¡ˆè¨­å®š â†’ Cloud Messaging
APNs Authentication Key â†’ ä¸Šå‚³ .p8 æª”æ¡ˆ
è¼¸å…¥ Key ID å’Œ Team ID
```

### C. ç’°å¢ƒè®Šæ•¸ç®¡ç†

```bash
# Firebase Functions ç’°å¢ƒè®Šæ•¸
firebase functions:config:set trackw.token="YOUR_TOKEN"
firebase functions:config:get  # æŸ¥çœ‹æ‰€æœ‰è®Šæ•¸

# æœ¬åœ°æ¸¬è©¦ï¼ˆfunctions/.env.localï¼‰
TRACKW_TOKEN="YOUR_TOKEN"

# iOS Secrets.swiftï¼ˆå·²å­˜åœ¨ï¼‰
static let trackTwAPIToken = "YOUR_TOKEN"
```

---

## çµèª

æ­¤å¯¦æ–½è¨ˆåŠƒæ¶µè“‹äº†å¾ Firebase åŸºç¤è¨­å®šåˆ°å®Œæ•´æ¨æ’­ç³»çµ±çš„æ‰€æœ‰æ­¥é©Ÿã€‚æ¡ç”¨åˆ†éšæ®µå¯¦æ–½ç­–ç•¥ï¼Œæ¯å€‹éšæ®µéƒ½æœ‰æ˜ç¢ºçš„ç›®æ¨™å’Œé©—è­‰æ–¹æ³•ï¼Œé™ä½é–‹ç™¼é¢¨éšªã€‚

é è¨ˆ **9-13 å¤©**å®Œæˆæ‰€æœ‰é–‹ç™¼ï¼Œä¸¦åœ¨ Firebase Free Tier å…§æ”¯æ´ 100+ ç”¨æˆ¶ã€‚ç³»çµ±è¨­è¨ˆè€ƒæ…®äº†å¯æ“´å±•æ€§ã€æˆæœ¬æ•ˆç›Šå’Œç”¨æˆ¶é«”é©—ï¼Œç‚º PackageTraker æä¾›äº†ä¼æ¥­ç´šçš„å³æ™‚æ¨æ’­èƒ½åŠ›ã€‚
